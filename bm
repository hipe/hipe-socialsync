#!/usr/bin/env ruby

require 'rubygems'
require File.dirname(__FILE__)+'/markus/cli'
require File.dirname(__FILE__)+'/markus/structdiff'
#require 'hpricot'            # may be not being used anymore. old way to parse xml 
require 'nokogiri'           # for parsing responses from xml data from blog services
require 'yaml'               # for representing the intermediate data file
require 'rest_client'        # for pushing to blog services
require 'highline/import'    # for password prompting

module Markus

  class BlogMigratorException < Exception
  end
  
  class BlogMigratorFailure < BlogMigratorException
  end
  
  class BlogMigrator    

    include Cli::App

    CDATA_RE = /\A<!\[CDATA\[(.*)\]\]>\Z/m    
    VERSION = '0.01-beta'

    def initialize
      cli_pre_init
      @intermediate_filename = 'tmp.wp2tumblr.yml'
      @date_range = nil
      @limit = nil   
      @is_dry_run = false
      @sort_by = nil
      @objects = []
      @cli_description = %{("blog migrator") Import your wordpress blogs into tumblr.}
      @cli_commands[:help]        = @@cli_common_commands[:help]
      @cli_global_options[:debug] = @@cli_common_options[:debug]
      @cli_global_options[:help]  = @@cli_common_options[:help]      
      @cli_commands[:pull] = {
        :description => 'parse wordpress xml into an intermediate yml file.',
        :splat => {
          :name => :XML_IN,
          :minimum => 1,
          :description => 'a list of one or more wordpress XML dump files to take in.',
          :validations => [
            {:type=>:file_must_exist},
            {:type=>:regexp, :regexp=>/\.xml\Z/,
             :message=>"Sorry, expecting the filename to end in *.xml."
            }
          ],
          # :action => {:action=>:open_hpricot}
        },
        :options => {
          :limit => {
            :description => "the grabbing phase will stop after it grabs this many items",
            :validations => [:type=>:regexp, :regexp=>/^(\d+)$/, :message=>'must be an integer'],
            :action      => Proc.new{|x| x[0].to_i}
          },
          :sort_by => {
            :description => %q{
            during the grab phase it will sort the items in this order for the push phase.  
            Multiple sort-by's may eventually be supported when there are multiple available criteria.  
            Available criteria are: ("post_date"). The criteria must be affixed with 'ascending' or 'descending'.  
            Example: --sort-by="author ascending" --sort-by="post_date descending"}.gsub(/\n */,''),
            :validations => [ :type=>:regexp, :regexp=>/^([_a-z]+) (ascending|descending)$/, 
              :message => %[must be of the form "FIELD {ascending|descending}"] ],
            :action      => Proc.new{ |x| {:field => x[0], :order => x[1] } }
          }
        }
      }
      datetime = '\d\d(?:\d\d)?-\d\d?-\d\d?(?: \d\d?:\d\d(?::\d\d)?)?{0,2}'
      @cli_commands[:push] = {
        :description => "push the intermediate yml file up to tumblr",
        :required_arguments => [
          {:name=>:TUMBLR_ACCOUNT_EMAIL, :description=>'the email address of your tumblr account'}
        ],
        :options => {
          :sleep_every => {
            :description => %{sleep for n seconds after you push these many items, e.g. --sleep-after="10"},
            :validations => [{:type=>:regexp, :regexp=>%r{^([1-9]\d*)$},
                :message=>"must be a positive integer, e.g. --sleep-after='10'"}]
          
          },
          :sleep_for => {
            :description => %{sleep for this many seconds after n items you push, e.g. --sleep-for="0.123" },
            :validations => [{:type=>:regexp, :regexp=>%r{^(\d+(?:\.\d+)?)$},
              :message=>"must be a floating point for seconds e.g. '1' or '0.123'"}]
          },
          :date_range => {
            :getopt_letter => 'a',  # don't get in the way of -d for debug
            :description => %{The range of dates of the blogs you want to push, e.g. }+
            %{"--date-range='2010-01-01 10:10 - 2010-02-01 5:55:55'".  (note that the spaces around the middle }+
            %{are important. and a date like "2001-02-03" (with no time) actually means midnight of the previous day.},
            :validations => [{:type=>:regexp, :regexp=>%r{^(#{datetime})? - (#{datetime})?$},:message=>"see description"}]
          },
          :dry_run => {
            :getopt_letter => 'r',             # don't get in the way of -d for debug
            :getopt_type   => Getopt::BOOLEAN, 
            :description   => %{Don't actually push these up, just show a preview of what you would do.}
          }
        }
      } # end command push to tumblr    
      @cli_commands[:delete] = {
        :description => "delete items from tumblr by id",
        :required_arguments => [
          {:name=>:TUMBLR_ACCOUNT_EMAIL, :description=>'the email address of your tumblr account'},
          {:name=>:IDS,                  :description=>'a comma-separated list of ids to erase'} 
        ]
      } # end command push to tumblr      
      @cli_commands[:push][:options][:limit] = @cli_commands[:pull][:options][:limit].clone
      @cli_commands[:push][:options][:limit][:description] = "it will only push this many items."
      cli_post_init
    end # end initialize

    def tumblr_generator_name
      return File.basename(__FILE__)+' version '+VERSION
    end

    def cli_activate_opt_or_arg_open_hpricot action, var_hash, var_name
      cli_activate_opt_or_arg_open_file({:as=>'r'}, var_hash, var_name)
      @cli_files[var_name][:fh] = Hpricot(cli_file(var_name)) # overwrite
    end

    def cli_execute_pull
      get_items
      post_process_items
      print_summary_info      
    end                                
        
    def describe_date_range
      "between "+@date_rangep[0]+" and "+@date_range[1]
    end
    
    # note that here it sort of kills the point of trying to save on memory
    def cli_execute_push                                   
      prompt_for_password                   
      struct = false
      File.open(@intermediate_filename, 'r') { |fh| struct = YAML::load fh }
      raise BlogMigratorException.new(%{failed to parse "@intermediate_filename" as YAML!}) if false===struct
      @num_articles_pushed = 0
      begin
        catch( :limit_reached ){ struct[:articles].each { |article| consider_item article } }
      rescue SocketError => e
        puts %{Got a socket error: "#{e.message}" -- Is your internet on?  Do you *have* the Internet?}
        exit
      rescue RestClient::RequestFailed => e
        puts %{Couldn't connect to "#{@last_url}".  Resouce Not Found! ("#{e.message}") -- are you sure you're connected to the internet? }
        exit
      rescue RestClient::RequestFailed => e
        print %{Failed to push blog entry to target site! Got an exception of type "#{e.class}" }+
        %{that says: "#{e.message}".  We got this response body: "#{e.response.body}".\n\n}+
        %{We tried to push this blog entry: }
        puts "Failed! --\n\n"
        @post_data = @post_data.clone
        @post_data[:body] = truncate(@post_data[:body],60)        
        pp @post_data, str = ''; print str
        puts "\n\nAnd that's the end of the error.\n"
        exit
      end
      puts "done pushing #{@num_articles_pushed} articles to tumblr."            
    end
    
    def consider_item article
      if (@date_range)
        article_datetime = DateTime.parse(article[:post_date])     
        if (@date_range[0] && article_datetime < @date_range[0] )
          print '[too old]'; return
        end
        if (@date_range[1] && article_datetime > @date_range[1] )
          print '[too new]'; return
        end
      end   
      post_data = make_post_data article    
      # ppp :thing, post_data, 1
      if post_data[:body].empty?
        puts %{skipping article with empty body from #{post_data[:date]} ...}
        return
      end
      push_item_to_tumblr post_data     
      
      if (@limit && @num_articles_pushed >= @limit)
        puts %{Reached limit of #{@limit} items}
        throw :limit_reached            
      end
      
      ## try adding sleep to avoid timeout
      if (@sleep_every && ( @num_articles_pushed % @sleep_every == 0 ) )
        puts %{After pushing #{@sleep_every} items, will sleep for #{@sleep_for} seconds}
        sleep @sleep_for
      end

    end      
    
    def make_post_data article
      @post_data = {
        :title =>       article[:title],
        :body =>        article[:content],
        :email =>       @cli_arguments[:TUMBLR_ACCOUNT_EMAIL],
        :password =>    @password,
        :type =>        'regular',
        :generator =>   tumblr_generator_name,
        :date =>        article[:post_date],
        :private =>     0,
        :tags =>        article[:tags],
        :format =>      'html'  # html | markdown        
      }
    end
    
    def push_item_to_tumblr post_data
      # http://www.tumblr.com/docs/api#api_write
      @post_date_str = post_data[:date]      
      print %{attempting to post article from #{@post_date_str} ...}
      @last_url = 'http://www.tumblr.com/api/write'
      if (@is_dry_run)
        print "(dry run)" 
        sleep 0.5
      else
        resp = RestClient.post(@last_url, post_data) #throws on fail        
        print %{(tublr id: "#{resp}")}
      end
      @num_articles_pushed += 1
      print "..done.\n"
    end
                         
    def prompt_for_password
      question = "Please enter your tumblr account password for #{@cli_arguments[:TUMBLR_ACCOUNT_EMAIL]}: ";
      @password = ask(question) { |q| q.echo = '*' }      
      # puts %{HARDCODED PASSWORD BEING ENTERED HERE!!! #{File.basename(__FILE__)} #{__LINE__}}
      # @password = 'mmmmmmmm'
    end
    
    def cli_execute_delete
      prompt_for_password
      ids = @cli_arguments[:IDS].split ','
      ids.each do |id|     
        raise BlogMigratorException.new(%{invalid id for item to delete: "#{id}"}) unless /^\d+$/ =~ id        
        args = {      
          %s{post-id}  => id,
          :email       => @cli_arguments[:TUMBLR_ACCOUNT_EMAIL],
          :password    => @password
        }
        @last_url =   'http://www.tumblr.com/api/delete'
        begin     
          print %{attempting to delete #{id}...}
          resp = RestClient.post(@last_url, args)
        rescue RestClient::RequestFailed => e
          if (403==e.http_code)
            print "request failed (code 403) -- already deleted?"
          else
            print %{unexpected failure:  "e.message"}
          end
        else
          print %{tumblr says:"#{resp}"}
        end
        print "\n"        
      end
    end
    
    def cli_process_option_date_range(given_opts, k)
      md = given_opts[k]
      @date_range = [
        md[0].nil? ? nil : DateTime.parse(md[0]),
        md[1].nil? ? nil : DateTime.parse(md[1])
      ]
      if (@date_range[0].nil? && @date_range[1].nil?)
        raise BlogMigratorException.new("Failed to process date range from "+md.inspect)
      end
    end
    
    def cli_process_option_dry_run(given_opts, k)      
      @is_dry_run = true
    end                 
    
    def cli_process_option_sleep_every(given_opts, k)
      @sleep_every = given_opts[k][0].to_i
      @sleep_for ||= 3.0
    end

    def cli_process_option_sleep_for(given_opts, k)   
      @sleep_for = given_opts[k][0].to_f
      @sleep_every ||= 5
    end
    
    def cli_process_option_limit(given_opts, k)
      @limit = given_opts[k]
    end
    
    def cli_process_option_sort_by(given_opts, k)
      @sort_by = given_opts[k]
    end
    
    # say as little of a sentence as you need to.
    #* ''extraction candidate''
    def minimize template, values
      @last_template ||= nil
      @last_values ||= nil
      if (template == @last_template)
        # they will alwyas have the same keys, so we look at middle        
        diff = StructDiff::diff(@last_values, values) 
        @last_values = values
        ret = " and "+(diff.middle_diff.map do |key,value|
          value_string = value.right.to_s.match(/^[0-9]+$/) ? value.right.to_s : %{"#{value.right}"}          
          %{#{key}#{value_string}} 
        end * " with ")
      else
        @last_template = template
        @last_values = values
        ret = "\n" + template_render( template, values )
      end
      ret
    end
    
    #* ''extraction candidate
    def template_render template, values
      ret = template.clone #* ''TODO'' test if this is necessary
      values.each{|k,v| ret.gsub! %{%%#{k}%%}, v}
      ret
    end
    
    def get_items
      @summary_info = {
        :skipped => {
          :because_of_status => {},
          :because_of_no_content => 0 },
        :grabbed => 0,
        :number_of_files => 0
      }
      filenames = @cli_arguments[:XML_IN] #Dir[@cli_arguments[:XML_IN]]
      catch( :limit_reached ) do 
        filenames.each do |filename|
          _get_articles_from_xml_file filename
        end
      end
    end
    
    def print_summary_info
      print( "\n\n"+((('='*80)+"\n")*1)+"\nSummary: wrote intermediate file \"#{@intermediate_filename}\" with:\n" )
      print "of items in wordpress xml "+ fun_summarize(@summary_info);
      print "\n"      
    end
    
    def _get_articles_from_xml_file filename
      print( %{\n\n#{'='*20} #{Cli::App.truncate(filename,38)} #{'='*20}\n} )      
      raise Cli::SyntaxError.new(%{File must exist: "#{filename}"}) unless File.exist?(filename)
      doc = nil
      begin
        # doc = Hpricot(filename)       
        File.open(filename) do |fh|
          doc = Nokogiri::XML(fh ,nil,nil,Nokogiri::XML::ParseOptions::STRICT)
        end
      rescue Nokogiri::XML::SyntaxError => e
        puts %{EROOR: failed to parse "#{filename}" as well-formed XML!  skipping file. Error: "#{e.message.strip}"}
        return
      end
      @summary_info[:number_of_files] += 1
      # doc.search('/rss/channel/item').each do |item|  if hpricot
      doc.xpath('/rss/channel/item').each do |item_node|
        obj = nokogiri_get_item_info item_node #obj = hpricot_get_item_info(item_node)
        if ! (['publish','inherit'].include?(obj[:status])) 
          print minimize(%q{Skipping article #%%#%% because of status "%%status %%"},
            "#" => obj[:art_id],"status "=>obj[:status])
          @summary_info[:skipped][:because_of_status][obj[:status].to_sym] ||= 0
          @summary_info[:skipped][:because_of_status][obj[:status].to_sym] += 1                  
        elsif (obj[:content].length == 0)
          print minimize(%{\nSkipping article #%%#%% with empty content (probably an uploaded attachment)},
            '#' => obj[:art_id])
          @summary_info[:skipped][:because_of_no_content] += 1
        else
          print minimize(%{\nGrabbing article #%%#%%},'#' => obj[:art_id])
          @summary_info[:grabbed] += 1
          hold_item obj
          if (@limit && @summary_info[:grabbed] >= @limit)
            puts %{\nReached limit of #{@limit} items.}
            throw :limit_reached
          end
        end
      end # each item
    end # def get_items  
    
    # here's the spot where we might change this if we switch to sqlite
    def hold_item obj
      @objects << obj
    end
    
    def post_process_items
      if (@sort_by)
        raise BlogMigratorException.new(%{Sorry, we don't recognize the sort-by field "%{@sort_by[:field]}"}) unless 
          (@sort_by.instance_of?(Hash) && 'post_date' == @sort_by[:field])

        symbol = @sort_by[:field].to_sym
        if ('ascending'==@sort_by[:order])
          sorter = Proc.new{|x,y| DateTime.parse(x[symbol]) <=> DateTime.parse(y[symbol]) }
        else 
          sorter = Proc.new{|x,y| DateTime.parse(y[symbol]) <=> DateTime.parse(x[symbol]) }
        end
        @objects.sort!( &sorter )
        puts %{Sorted items by date #{@sort_by[:order]}}
      end

      File.open(@intermediate_filename,'w') do |fh|
        fh.write(":articles:\n");        
        @objects.each do |object|
          yaml_obj = YAML::dump object
          s = yaml_obj.to_s # in order to take this yaml dump and put it inside of another yaml tree...
          s.sub!(/\A--- \n/, ''); # remove this thing from the beginning of the yaml dump..
          s = '- '+s.gsub(/\n(?!\Z)/, "\n  ") # and indent appropriately 
          fh.write s         
        end
      end
      
    end # post_process_items
    
    def nokogiri_get_item_info(node)
      obj = {}
      obj[:title]       = node.at_xpath('./title').content
      obj[:status]      = node.at_xpath('./wp:status').content
      obj[:art_id]      = node.at_xpath('./wp:post_id').content
      obj[:content]     = node.at_xpath('./content:encoded').content
      obj[:author]      = node.at_xpath('./dc:creator').content
      obj[:post_date]   = node.at_xpath('./wp:post_date').content
      obj[:tags] = []
      node.xpath('./category[@domain="tag" and @nicename]').each do |cat|
        obj[:tags] << cat.content
      end
      obj[:tags] = obj[:tags] * ',' # meh for readability
      obj
    end
    
    def hpricot_get_item_info(node)
      raise Exception.new("now we need to implement tags for this puppy if we ever use it")
      obj = {}
      obj[:title]       = node.at('title').inner_html      
      obj[:status]      = node.at('wp:status').inner_html
      obj[:art_id]      = node.at('wp:post_id').inner_html
      obj[:content]     = unescape_cdata( (node/'content:encoded').inner_html )
      obj[:author]      = unescape_cdata( (node/'dc:creator').inner_html )
      obj[:post_date]   = (node/'wp:post_date').inner_html
      obj
    end  
    
    # expects an arbirarily deep nested hash with symbol names and values that are either
    # (leave node) an integer or (tree node) another such hash.  returns an array of lines indented appropiratel
    def _fun_summarize(hash, indent_amt='  ', current_indent='', parent_key = nil)
      my_total = 0;
      my_lines = []      
      hash.each do |key,value|
        left_side = ([parent_key.to_s,key.to_s].compact * '_').gsub!(/_/, ' ')
        if (value.instance_of? Fixnum)
          my_lines << %{#{current_indent}#{left_side}: #{value}}
          my_total += value
        else
          child_lines,child_total = _fun_summarize(value, indent_amt, current_indent+indent_amt, key)
          my_lines << %{#{current_indent}#{left_side} (#{child_total} total):}
          my_total += child_total          
          my_lines += child_lines
        end
      end
      [my_lines, my_total]
    end
    
    def fun_summarize(hash, indent_amt='  ')
      lines, total = _fun_summarize(hash, indent_amt, current_indent='  ')
      %{(#{total} total):\n}+(lines * "\n")
    end

    def unescape_cdata str
      matches = CDATA_RE.match(str)
      unless matches
        throw Exception.new(self.truncate("failed to match #{str} against #{self.re.to_s}\n",160))
      end
      return matches[1]
    end # def unescape_cdata
  end # class BlogMigrator
end # module Markus
Markus::BlogMigrator.new.cli_run if $PROGRAM_NAME == __FILE__